#### 18. Задачи. Как будет работать код с использованием Future, если для методов get() и set() используется synchronized, но по бизнес-логике не допускается перезапись переменной slot? Нужно ли применить паттерн double-check и как это исправить?

```java

public class SettableFuture<V> implements Future<V> {
    private volatile V slot;

    public V get() throws InterruptedException, ExecutionException {
        synchronized(this) {
            while (slot == null) {
                wait();
            }
        }
        return slot;
    }

    public void set(V value) {
        if (slot == null) {
            slot = value;
            synchronized(this) {
                notifyAll();
            }
        }
    }
}
```

{{< hint warning >}}
**Спойлеры к решению**  
{{< /hint >}}

{{< details "Подсказки" close >}}

- В текущем коде используется синхронизация для методов `get()` и `set()`, но есть возможность перезаписать значение переменной `slot`, что не соответствует бизнес-логике.
- Чтобы предотвратить нежелательную перезапись, нужно гарантировать, что метод `set()` не перезапишет уже установленное значение.
- Паттерн **double-check** часто используется, чтобы избежать ненужной синхронизации в многопоточной среде, проверяя значение переменной дважды: один раз до блокировки и второй — внутри синхронизированного блока.
- В данном случае нужно внести изменения, чтобы синхронизация не нарушала логику, и добавьте правильную проверку на перезапись.

{{< /details >}}

{{< details "Решение" close >}}

Для того чтобы избежать перезаписи переменной `slot`, и при этом сохранить синхронизацию, можно внести следующие изменения:

```java
public class SettableFuture<V> implements Future<V> {
    private volatile V slot;

    public V get() throws InterruptedException, ExecutionException {
        synchronized(this) {
            while (slot == null) {
                wait();
            }
        }
        return slot;
    }

    public void set(V value) {
        if (slot == null) {  // Проверка на null до синхронизации
            synchronized(this) {
                if (slot == null) {  // Double-check внутри синхронизации
                    slot = value;
                    notifyAll();
                }
            }
        }
    }
}
```

**Объяснение изменений:**

1. В методе `set()` добавлена проверка `if (slot == null)` перед синхронизацией. Это помогает избежать ненужной блокировки, если значение уже установлено.
2. После синхронизации добавлена дополнительная проверка `if (slot == null)` внутри синхронизированного блока. Это и есть паттерн **double-check**, который гарантирует, что значение будет установлено только один раз, даже если несколько потоков одновременно вызывают метод `set()`.
3. Таким образом, блокировка применяется только в случае, если необходимо установить значение, и это происходит только один раз. Это исправляет логику, не позволяя перезаписывать переменную `slot`.

Теперь этот код работает корректно и не допускает перезаписи переменной, соблюдая нужную бизнес-логику, а паттерн double-check позволяет улучшить производительность, избегая лишней синхронизации.
{{< /details >}}